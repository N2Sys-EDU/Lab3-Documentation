# Lab3

Lab3分为两个部分：
1. 使用ebpf技术，实现一个NAT，实现内网和外网的通信。
2. 使用ebpf技术，基于UDP协议，实现一个简单的代理。

## 1.网络结构

在Lab3中，我们考虑一个日常生活中使用的网络结构。

![](net.png)

局域网设备通过一个路由器和广域网进行通信。
局域网设备的网关均为路由器IP。

为了简化实验，我们对网络拓扑做出如下假设：
1. 网络不存在嵌套的情况，即只有广域网和局域网两层，并且路由器只有一个接口连接到广域网。
2. 每台机器均有一个所在网段的唯一IP地址。
3. 广域网中的所有机器，通过一个交换机连接。
4. 我们规定，局域网的网段为192.168.1.0/24，广域网的网段为10.0.0.0/8。
5. 除路由器外的计算机均只有一个端口，或者连接到路由器，或者连接到广域网。

## 2. 功能要求

你需要实现NAT和代理，实现如下效果：一个局域网中的机器可以正常访问广域网的服务器，同时对于那些屏蔽了来自该局域网流量的服务器，你也可以通过广域网中的一个代理服务进行正常访问。
对于NAT，你需要实现一个程序进行地址协议转换，以实现内网正常访问广域网的服务器。
对于代理，你需要实现两个程序：代理客户端和代理服务器。
代理客户端将你的报文转发到代理客户端，代理服务器将你的请求伪装成从代理服务器发出的请求发出。
他们部署的位置如下图所示：

// 修改图，让他看上去是个程序，不用logo，用方框

![](proxy_pos.png)

在一个完整的工作流中，客户端发出的报文首先经过代理客户端，代理客户端根据报文的目的地址，改写报文的目的地。
然后，报文会到达路由器，经过NAT协议，发到广域网中。
最终到达目的机。
如果该报文是一个代理客户端改写的，到达代理服务器的报文，那么该报文会被代理服务器再次改写，然后转发到原本的目的地。
其他广域网服务器发出的报文会经过代理服务器改写，经过NAT发回到某个代理客户端，改写后递交给客户端上的应用程序。

### 2.1 NAT

对于存在广域网端口的路由器，它需要支持NAT功能。
一个路由器会有一个接口连接到广域网，以及若干个接口，连接到内网的机器。
对于这个程序，你需要实现两个模块。
一个处理所有去往广域网的报文，一个处理所有来自广域网的报文。

**上行模块.** 对于来自局域网端口的报文，若下一跳将从广域网端口发出，则需要执行网络地址转换。
即若该报文源地址尚未分配广域网地址，则需要为该源地址分配一个可用广域网地址，并将报文中的源地址替换为对应广域网地址后再发出。
若没有空闲的可用广域网地址，则丢弃该报文。
该模块将被部署在路由器上，拦截所有通过广域网接口**发往**广域网的报文。
你需要检查该报文的(源地址,源头端口,传输层协议)是否存在对应的(目标广域网地址,目标广域网端口,传输层协议)的映射。
如果不存在，则通过随机算法创建一个这样的映射。
然后，根据映射替换报文中的源地址、端口后发出。

**下行模块.** 对于来自广域网端口的报文，若其目的地址不是该路由器已分配的广域网地址，则直接丢弃。
否则将目的地址转换为对应的局域网地址后再上交给内核网络协议栈继续处理。
该模块将被部署在路由器上，拦截所有**来自**广域网的报文。
你需要检查该报文的(目标广域网地址,目标广域网端口,传输层协议)是否存在对应的(源地址,源头端口,传输层协议)。
如果不存在，则不处理。
如果存在，则根据映射替换报文中的目标地址、端口后递交内核网络协议栈继续处理。

### 2.2 代理客户端

代理客户端由两个模块构成，部署在路由器上。
上行模块负责处理所有从局域网机器去往路由器的报文。
下行模块负责处理所有从路由器机器去往局域网机器的报文。

**上行模块.** 对于所有从客户端去往路由器的报文，我们可以通过一个报文的目的地址判断该报文是否需要通过代理来发送。
对于需要被代理的报文，我们在他们的IP头前插入一个新的IP头和UDP头，以将该报文转发到代理服务器。
更具体的，原本报文的头部格式如下：
```
|IP from 客户端 to 目标|TCP/UDP|
```
在经过代理包装后：
```
|IP from 客户端 to 代理服务器|UDP to 代理服务器端口|IP from 客户端 to 目标|TCP/UDP|
```
这样，这个报文就会被网络传输到代理服务器，而不是目标。
该模块将被部署在路由器上，拦截所有**来自**局域网端口的报文，在处理后再交给路由器。

**下行模块.** 代理服务器在收到目标服务器想要发给客户端的报文时，会转发回客户端。
这些报文在到达客户端时同样经过封装，形如：
```
|IP from 代理服务器 to 客户端|UDP from 代理服务器端口|IP from 目标 to 客户端|TCP/UDP|
```
我们需要将前面的IP和UDP头去掉，还原为原本的报文形式，然后从路由器发往客户端。
```
|IP from 目标 to 客户端|TCP/UDP|
```
该模块部署在路由器上，拦截所有**发往**客户端的报文。
如果一个报文是来自代理服务器的报文，那么去掉前面的IP头和UDP头，然后再递交给客户端。

### 2.3 代理服务端

代理服务端包含一个模块，运行在代理服务器上。
代理服务端将局域网的报文伪装成从代理服务器发出。
同时，将来自其他广域网机器的目标为代理服务器的报文，伪装成发往局域网的报文。
代理服务端的工作分为两个部分：监听来自代理客户端的报文，以及转发其他机器的报文。

**模块1.** 首先，代理服务端会通过监听UDP某个特定端口上的，来自来自代理客户端的报文。
其格式均为：
```
|IP to 代理服务端|UDP to 代理服务端|IP from 局域网|TCP/UDP from 局域网|Data|
```
第一步，我们将报文恢复为原本的格式：
```
|IP from 局域网|TCP/UDP from 局域网|Data|
```
第二步，我们需要伪装成从代理服务器访问该报文的目标机器。
因此，我们需要对源地址进行替换。
即我们需要查找一个从(局域网地址，局域网端口，传输层协议)到（代理服务器端口，传输层协议）的映射。
如果没有，则根据随机算法创建一个映射。
根据映射，将报文修改为：
```
|IP from 代理服务器|TCP/UDP from 代理服务器端口|
```
后发出，这样报文就会被认为来自代理服务器，并被发到目标机器。
其次，如果一个报文来自其他服务器，其的目的是已经被映射的（代理服务器地址，传输层协议），那么这个报文应当被转发回代理客户端。
报文原本的格式应当为：
```
|IP from 其他广域网机器 to 代理服务器|TCP/UDP to 代理服务器|
```
第一步，我们应根据映射将报文的目标地址替换回代理客户端的地址：
```
|IP to 局域网|TCP/UDP to 局域网|
```
第二步，我们重新封装该报文为代理报文。
```
|IP from 代理服务器|UDP to 代理服务器|IP to 局域网|TCP/UDP to 局域网|
```
将该报文发出后，该报文会被网络转发回代理客户端。

## 3. 样例

为了更好的理解以上的功能，我们提供了两个样例用以说明NAT和代理的工作流程。

// 网络接口和设备看上去是分离的设备

网络的拓扑如下图所示：
![](example_topo2.png)
所有源地址为C的报文都将被D拒绝接收。
客户端将从TCP://A:12发起一个向TCP://D:34端口的连接。

首先，客户端发起链接，发出报文：
![](example_step5.png)
**代理客户端.上行模块**监测到该报文需要被代理，因此进行了重新封装。
这里，我们认为用于代理通信的端口为UDP的12345端口。
封装后的报文被递交给路由器进行转发：
![](example_step6.png)
对于一个发往广域网的报文，**NAT.上行模块**创建了一个映射，并改写了该报文的源地址和端口：
![](example_step7.png)
部署在代理服务器上的**代理服务端**建立映射。
将该报文改写，伪装成从代理服务器发出后转发：
![](example_step8.png)
该报文会到达目标服务器D并被正常处理。

D回复报文时，报文会被首先发送给E。
这是因为对D来说，该回复是针对E的：
![](example_step9.png)
**代理服务端**检查到映射存在时，将报文进行改写，然后重新封包发回给代理客户端：
![](example_step10.png)
**NAT.下行模块**检查到映射存在，将报文的目标地址改写，然后转发给客户端。
![](example_step11.png)
**代理客户端.下行模块**对来自代理服务器去往客户端的报文进行解包，去掉多余的IP头和UDP头，然后递交给客户端：
![](example_step12.png)

对客户端上的应用程序来说，就像是在和服务器正常进行通信。
对服务器来说，就像是和代理服务器在正常通信。

## 4. 技术规范

接下来你需要为每个模块实现一个函数，每个函数会传入一个参数，参数中包含了报文的信息。
你可以在函数中对报文进行处理。
根据返回值的不同，你可以选择性的让报文通过/丢弃/转发。

如果一个程序部署在某个设备上，处理的是离开这个设备的报文，那么函数格式如下：
``` c
int any_name(struct __sk_buff* skb) {
    void *data = (void *)(long)skb->data; // 报文的头部
    void *data_end = (void *)(long)skb->data_end; // 报文的结尾

    struct ethhdr *eth = data; // 以太网头
    // TODO 你的程序
    return TC_ACT_OK; // 发送该报文
    return TC_ACT_SHOT; // 丢弃该报文
}
```
如果一个程序部署在某个设备上，处理的是即将到达这个设备的报文，那么函数格式如下：
``` c
int any_name(struct xdp_md* ctx) f{
    void* data_end = (void*)(long)ctx->data_end; // 报文的头部
    void* data = (void*)(long)ctx->data; // 报文的尾部

    struct ethhdr* eth = data; // 以太网头
    // TODO 你的程序
    return XDP_PASS; // 将修改后的报文接收进来
    return XDP_DROP; // 将报文丢弃
    return XDP_TX; // 将修改后的报文从来的地方发回去
}
```
你需要实现的是，其中**你的程序**的部分，你需要根据不同模块的需求实现其中的代码。
一些辅助函数和开发技巧参见**扩展阅读：ebpf**。

> 你可以修改/添加的文件仅限于`user/`目录下的内容。
> 一些需要的头文件已经写在了`test_utils/common.h`中。
> 我们只需要你的实现支持UDP和TCP。
> 在改写的过程中，我们要求IP和TCP的校验和保持正确。
> UDP的校验和可以直接设置为0。

### 4.1 NAT

NAT的两个模块的代码，分别为NAT.上行模块(`user/nat_module_1.c`)和NAT.下行模块(`user/nat_module_2.c`)。

`user/nat_module_1.c`将被部署在路由器上，捕获离开路由器，即将进入广域网的报文。
代码的入口如下：
``` c
// user/nat_module_1.c
SEC("xdp_ingress")
int xdp_ingress_func(struct xdp_md* ctx) {
    return XDP_PASS;
}
```
所有即将离开路由器，进入广域网的报文都将调用该函数，报文的信息存放在`struct xdp_md* ctx`结构体中。
你可以在该函数中对报文进行改写，然后再发往广域网。

`user/nat_module_2.c`将被部署在路由器上，捕获所有来自广域网的报文。
代码的入口如下：
``` c
// user/nat_module_2.c
SEC("tc_egress")
int tc_egress_func(struct __sk_buff* skb) {
    return TC_ACT_OK;
}
```
所有来自广域网的报文都将调用该函数，报文的信息存放在`struct __sk_buff* skb`结构体中。
你可以在该函数中对报文进行改写，再交给路由器。
路由器会根据你改写后的内容进行转发。

### 4.2 代理客户端

代理客户端的两个模块的代码分别为代理客户端.上行模块(`user/proxy_client_module_1.c`)和代理客户端.下行模块(`user/proxy_client_module_2.c`)。

`user/proxy_client_module_1.c`将被部署在路由器上，拦截所有从局域网客户端发往路由器的报文。
代码的入口如下：
``` c
// user/proxy_client_module_1.c
SEC("xdp_ingress")
int xdp_ingress_func(struct xdp_md* ctx) {
    return XDP_PASS;
}
```
所有来自客户端的报文都将调用该函数，报文的信息存放在`struct xdp_md* ctx`结构体中。
你可以在这里对报文进行改写，再交给路由器。
路由器会根据你改写后的内容进行转发。

`user/proxy_client_module_2.c`将被部署在路由器上，拦截所有从路由器发往客户端的报文。
代码的入口如下：
``` c
// user/proxy_client_xdp.c
SEC("tc_egress")
int tc_egress_func(struct __sk_buff* skb) {
    return TC_ACT_OK;
}
```
所有从路由器发向局域网机器的报文都将调用该函数，报文的信息存放在`struct __sk_buff* skb`结构体中。
你可以在函数中改写相关的报文，在改写后再交给客户端的协议栈进行处理。

我们将如下的报文从客户端发送到路由器，报文将被代理客户端上行模块(`user/proxy_client_module_1.c`)截获。
通过解析报文的内容添加/删除代理规则。
对于命中代理规则的报文，应当使用代理进行通信。
``` c
struct ethhdr {
    ...
    uint16_t h_proto = 0x0101(添加一个规则)/0x0202(删除一个规则);
};
struct iphdr {
    ...
    uint32_t dst_ip = 0x0300000a;               // 规则的目标IP，在我们的实验中一定为10.0.0.3，即0x0300000a
    ...
    uint8_t protocol = IPPROTO_UDP/IPPROTO_TCP; // 规则的目标传输层协议
};
struct tcp/udphdr {
    ...
    uint16_t dest;                              // 规则的目标端口
}
```
> 相关的结构体包括`struct ethhdr, struct iphdr, struct tcphdr, struct udphdr`均在`netinet`头中有完整的定义。

### 4.3 代理服务端

代理服务端模块的代码为`user/proxy_server_module.c`。
该模块部署在代理服务器上，拦截所有发往代理服务器的报文。
``` c
// user/proxy_server.c

#define DST_IP 0x0300000a                               // 目标IP地址一定为 10.0.0.3
#define DST_ETH 0x02, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6      // 目标IP地址对应的Ethernet地址 一定为 0x02, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6

SEC("xdp_ingress")
int xdp_ingress_func(struct xdp_md* ctx) {
    return XDP_TX;
}
```
你需要对报文进行修改然后进行转发。

> 我们使用bpftool和iproute2对程序进行部署，具体部署的代码参见`scripts/load_ebpfs_proxy_client.sh`、`scripts/load_ebpfs_proxy_server.sh`以及`scripts/load_ebpfs_router.sh`。

## 5. 运行与测试

### 5.0 运行环境要求

> 我们建议同学们在clab平台上运行自己的测试，而不是在本地进行测试。
> 我们会提供用于本地测试需求的操作系统和软件包信息。
> 我们仅针对clab平台运行测试提供支持。
> Clab平台的使用说明参考文档：[快速上手](https://clab.pku.edu.cn/docs/getting-started/introduction)
> 在Clab中，我们使用Ubuntu22.04作为软件包脚本，具体申请方法参考以上文档以及习题课内容。

操作系统：Linux, Kernel版本>=5.15
软件包：
* clang-15：用于编译ebpf程序
* libbpf：用于编译ebpf程序
* kernel-headers：用于编译ebpf程序
* bpftool：用于部署ebpf程序
* iproute2：用于部署ebpf程序
* cmake：用于运行测试

打开运行环境的Terminal，执行以下指令即可安装以上列举的软件包。

``` bash
sudo apt update
sudo apt install clang-15 libbpf-dev linux-headers-$(uname -r) cmake linux-tools-common iproute2 linux-tools-$(uname -r) hping3
sudo ln -s /usr/bin/clang++-15 /usr/bin/g++
```

至此，环境配置完毕。

### 5.1 获取仓库

1. 从远程仓库 clone 
2. 在根目录中执行 `git submodule update --init`
3. 在根目录中执行 `git submodule update --remote`
4. 在根目录中执行 `mkdir build`
5. 在目录`/根目录/test_utils/scripts/`中执行`chmod a+x ./*`

执行完成后，你的目录树应当如下：

```
/根目录
    /build
    /test_utils
        /scripts
        /src
    /scripts
    /user
    /CMakeLists.txt
```

### 5.2 编译测试程序
在`/根目录/build`中执行`cmake .. && cmake --build .` ，这将编译本地测试程序

注意，若测试程序发生更新，请执行如下指令获取最新的测试程序（我们会在教学网和微信群进行通知）：

在根目录中执行 `git submodule update --remote` 即可更新测试程序代码，而不会影响到你的代码。

### 5.3 配置测试程序环境

在`/根目录/build`中执行`sudo ./../test_utils/scripts/setup.sh`即可配置测试环境。

**注意该脚本只需要每次开机执行一次。**

在`/根目录/build`中执行`sudo ./../test_utils/scripts/cleanup.sh`即可清除测试环境。

### 5.4 运行测试程序

在`/根目录/build`中执行`./Lab3_ebpf`即可运行全部测试。

你可以通过参数指定特定测试点进行测试，使用方式与 Lab 1 一致。

> 测试用脚本在`/根目录/test_utils/scripts`下。如果本地测试无法执行，你可以将同名文件放置在`/根目录/scripts`中。执行时将使用同名的`/根目录/scripts`中的脚本执行（该替换操作仅为方便同学本地运行设计，在提交测试时无法使用）。

## 6. 提交和评测

本次Lab总分 100 分

部分测试点在 Deadline 前放出，全部测试点会在 Deadline 后统一进行测试。我们会在数据点内容中详细描述所有测试点的测试内容。

**注意：Lab3和其他Lab1-2的评测/提交方式不同，请仔细阅读以下内容。**

**测试代码** 我们不提供Github Classroom评测功能，同学们可以使用Clab根据第五章内容自行测试，测试机型建议使用`elite_computing e2`。测试只提供部分测试点。

**提交代码** 同学们可以通过 Github Classroom 提交代码。Github Classroom 不提供，因此你会在 Github Classroom 中观察到0分，这是正常的。

**最终评测** 最终的测试环境会使用Clab的`elite_computing e2`机型。最终测试时会使用全部测试点，运行测试的方法和第五章完全相同。
> **Hack `test_utils`目录干扰最终评测的行为将直接记为0分**

### 6.1. 数据点

每一个测试点名由 `${类别}.${测试点名称}` 构成

<table>
    <tr>
        <td>类别</td>
        <td>测试点名称</td>
        <td>分数占比</td>
        <td>ddl 前放出</td>
        <td>数据点内容</td>
    </tr>
    <tr>
        <td rowspan="5">Basic</td>
        <td>Env</td>
        <td>0</td>
        <td>是</td>
        <td>测试运行环境是否正常</td>
    </tr>
    <tr>
        <td>NAT_UDP</td>
        <td>10</td>
        <td>是</td>
        <td>单流测试TCP NAT功能</td>
    </tr>
    <tr>
        <td>NAT_UDP</td>
        <td>10</td>
        <td>是</td>
        <td>单流测试UDP NAT功能</td>
    </tr>
    <tr>
        <td>ProxyAdd</td>
        <td>10</td>
        <td>是</td>
        <td>添加一条代理规则后，是否正常通信（包括代理和不被代理的流）</td>
    </tr>
    <tr>
        <td>ProxyDel</td>
        <td>10</td>
        <td>是</td>
        <td>删除代理规则后，是否正常通信（包括代理和不被代理的流）</td>
    </tr>
    <tr>
        <td rowspan="5">Multiflow</td>
        <td>TCP_NAT</td>
        <td>10</td>
        <td>是</td>
        <td>多流测试TCP NAT功能</td>
    </tr>
    <tr>
        <td>UDP_NAT</td>
        <td>10</td>
        <td>是</td>
        <td>多流测试UDP NAT功能</td>
    </tr>
    <tr>
        <td>ProxyAdd</td>
        <td>10</td>
        <td>是</td>
        <td>添加多条代理规则后，是否正常通信（包括代理和不被代理的流）</td>
    </tr>
    <tr>
        <td>ProxyDel</td>
        <td>10</td>
        <td>是</td>
        <td>随机添加删除多条代理规则后，是否正常通信（包括代理和不被代理的流）</td>
    </tr>
    <tr>
        <td>MIXED</td>
        <td>20</td>
        <td>否</td>
        <td>混合以上所有的测试点进行测试</td>
    </tr>
</table>